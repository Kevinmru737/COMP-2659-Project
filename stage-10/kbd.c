#include "kbd.h"

Kbd_Buffer kbd_buffer;
Vector orig_kbd_vector;

short mouse_state = NO_MOUSE_STATE;

int mouse_curr_x_pos = 320;
int mouse_curr_y_pos = 200;

int mouse_prev_x_pos = 320;
int mouse_prev_y_pos = 200;

volatile unsigned char *const IKBD_control  = 0xFFFFFC00;
volatile const unsigned char  *const IKBD_status  = 0xFFFFFC00;
volatile const unsigned char *const IKBD_RDR  = 0xFFFFFC02;

#define NULL '\0'
typedef enum {
    No_Special_Key,
    Caps_Lock_On,
    Left_Shift_Held,
    Right_Shift_Held
} KEY_STATE;

KEY_STATE key_state = No_Special_Key;


unsigned char caps_lock[] = {
0x0, 0x1b, 0x31, 0x32,
0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 
0x2d, 0x3d, 0x8, 0x9, 0x51, 0x57, 0x45, 0x52, 0x54, 
0x59, 0x55, 0x49, 0x4f, 0x50, 0x5b, 0x5d, 0xd, 0x0, 
0x41, 0x53, 0x44, 0x46, 0x47, 0x48, 0x4a, 0x4b, 0x4c, 0x3b, 0x27, 
0x60, 0x0, 0x5c, 0x5a, 0x58, 0x43, 0x56, 0x42, 0x4e, 0x4d, 0x2c, 0x2e, 
0x2f, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x0, 0x0, 0x2b, 0x0, 0x0, 0x0, 
0x0, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x28, 0x29, 0x2f, 0x2a, 0x37, 0x38, 0x39, 0x34, 0x35, 0x36, 0x31, 0x32, 0x33, 
0x30, 0x2e, 0xd };

unsigned char shifted[] = {
0x0, 0x1b, 0x21, 0x40, 0x23, 0x24, 0x25, 
0x5e, 0x26, 0x2a, 0x28, 0x29, 0x5f, 0x2b, 
0x8, 0x9, 0x51, 0x57, 0x45, 0x52, 0x54, 0x59,
0x55, 0x49, 0x4f, 0x50, 0x7b, 0x7d, 0xd, 0x0, 
0x41, 0x53, 0x44, 0x46, 0x47, 0x48, 0x4a, 0x4b, 
0x4c, 0x3a, 0x22, 0x7e, 0x0, 0x7c, 0x5a, 0x58, 
0x43, 0x56, 0x42, 0x4e, 0x4d, 0x3c, 0x3e, 0x3f, 
0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x37, 0x38, 0x0, 
0x2d, 0x34, 0x0, 0x36, 0x2b, 0x0, 0x32, 0x0, 0x30, 
0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 0x29, 0x2f, 0x2a, 0x37, 
0x38, 0x39, 0x34, 0x35, 0x36, 0x31, 0x32, 0x33, 0x30, 
0x2e, 0xd };

unsigned char unshifted[] = {
0x0,0x1b, 0x31, 0x32, 0x33, 0x34, 
0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 
0x2d, 0x3d, 0x8, 0x9, 0x71, 0x77, 0x65, 
0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 
0x5b, 0x5d, 0xd, 0x0, 0x61, 0x73, 0x64, 
0x66, 0x67, 0x68, 0x6a, 0x6b, 0x6c, 0x3b, 
0x27, 0x60, 0x0, 0x5c, 0x7a, 0x78, 0x63,
0x76, 0x62, 0x6e, 0x6d, 0x2c, 0x2e, 0x2f, 
0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x2d, 0x0, 0x0, 0x0, 0x2b, 0x0, 
0x0, 0x0, 0x0, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x28, 
0x29, 0x2f, 0x2a, 0x37, 0x38, 0x39, 0x34, 0x35, 0x36, 
0x31, 0x32, 0x33, 0x30, 0x2e, 0x0d 
};


void init_keyboard_isr() {
    kbd_buffer.rear = 0;
    kbd_buffer.front = 0;
    orig_kbd_vector = install_vector(KBD_VEC_NUM, kbd_isr);

}

void restore_keyboard_isr() {
    install_vector(KBD_VEC_NUM, orig_kbd_vector);
}


                                                                                                                                      

/*
 * Purpose: Main keyboard driver. Handles mouse as well as keyboard input
 */
void kbd_driver() {
    unsigned char value = *IKBD_RDR; 

    switch (mouse_state) {
        case NO_MOUSE_STATE:
            if (value >= 0xF8) {
                mouse_state = MOUSE_2nd_PACKET_STATE;
            } else {
                kbd_buffer.buffer[kbd_buffer.rear++] = value;
            }
            break;

        case MOUSE_2nd_PACKET_STATE:
            mouse_prev_x_pos = mouse_curr_x_pos;
            mouse_curr_x_pos += (char) value;
            mouse_state = MOUSE_3rd_PACKET_STATE;
            break;

        case MOUSE_3rd_PACKET_STATE:
            mouse_prev_y_pos = mouse_curr_y_pos;
            mouse_curr_y_pos += (char) value;
            mouse_state = NO_MOUSE_STATE;
            break;
    }

}




/*
 * Purpose: Checks if the keyboard buffer is empty. Returns TRUE if it is, FALSE otherwise
 *
 */
bool is_buffer_empty() {
    return kbd_buffer.front == kbd_buffer.rear ? TRUE: FALSE;
}



/*
 * Purpose:  Gets the next character from the keyboard buffer. Converts the scancode into ascii using KEy tables and also
 *          takes into account shift(left and right) and caps lock key. Retruns null if a break or special key is in the buffer
 */
unsigned char get_value_from_buffer() {
    unsigned char value = NULL; 

    while (is_buffer_empty() == FALSE && value == NULL) {
        value = kbd_buffer.buffer[kbd_buffer.front++];

        if (!((value & BREAK_CODE) == 0 || SHIFT_BREAK_CODES(value))) {
            value = NULL; 
            continue; 
        }

        switch (key_state) {
            case No_Special_Key: 
                handle_no_special_key(&value); 
                break;
            case Caps_Lock_On: 
                handle_caps_lock_on(&value); 
                break;
            default: 
            handle_shift_held(&value); 
                break;
        }
        break;
    }

    return value;
}

/*
 * Purpose: Processes the input character when no special keys (Caps Lock, Shift) are active.
 */
void handle_no_special_key(unsigned char* value) {
    switch(*value) {
        case CAPS_ON_MAKE_CODE:
            key_state = Caps_Lock_On;
           *value = NULL;
            break;
        case LEFT_SHIFT_MAKE_CODE:
            key_state = Left_Shift_Held;
            *value = NULL;
            break;
        case Right_SHIFT_MAKE_CODE:
            key_state = Right_Shift_Held;
            *value = NULL;
            break;
        default:
            *value = unshifted[*value];
            break;
    }
}

/*
 * Processes the input character when caps lock is on
 */
void handle_caps_lock_on(unsigned char* value) {
    if(*value == CAPS_ON_MAKE_CODE) {
        key_state = No_Special_Key;
        *value = NULL;
    } else {
        *value = caps_lock[*value];
    }
}

/*
 * Processes the input character when either the Left Shift or Right Shift key is held down.
 */
void handle_shift_held(unsigned char* value) {
    if((key_state == Left_Shift_Held && *value == LEFT_SHIFT_BREAK_CODE) ||
    (key_state == Right_Shift_Held && *value == Right_SHIFT_BREAK_CODE)) {
        *value = NULL;
        key_state = No_Special_Key;
    }else {
        if(*value == CAPS_ON_MAKE_CODE) {
            *value = NULL;
            key_state = Caps_Lock_On;
        } else {
            *value = shifted[*value];
        }

    }

}